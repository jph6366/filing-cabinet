#+title: Lemon Graphs
* LEMONgraphs.jl

* Graphs.jl
- network and graph analysis in julia
  - offering concrete graph implementations
    - /SimpleGraph/ for undirected graphs
    - /SimpleDiGraph/ for directed graphs
      - /AbstractGraph/ abstract type

- central package of JuliaGraphs ecosystem
  - additional functionality via
    - LightGraphsExtras.jl, MetaGraphs.jl, SimpleWeightedGraphs.jl, GraphIO.jl
      GraphDataFrameBridge.jl

basic example
#+begin_src julia
using Graphs

g = path_graph(6)
# # of verts
nv(g)
# # of edges
ne(g)
# add edge to make path a loop
add_edge!(g, 1, 6)
#+end_src

** Graph Types
- In addition to /SimpleGraph/SimpleDiGraph/
  - Graphs serves alternative graph types
    - (un)directed graphs with the ability to specify weights on edges
    - (un)directed graphs that supports UDF properties on graph, verts, and edges
    - supports massive graph structures in a space-time efficient manner
      - but is static, meaning its immutable once instantiated

        _which to use_?
        - prefer the simple implementaitons!
          - if we need edge weights and does NOT require large numbers of graph manipulations--use weighted graphs
            - if we need labeling of verts/edges use metadata graphs
              - if we have graphs with billions to tens of billions of edges and dont need mutability-- use static graphs

*** Concrete Types
1. _SimpleGraph_ and _SimpleDiGraph_
 - subtypes of _AbstractGraphs_ and system default integer type of Int64


- a graph /G/ is described by a set of vertices /V/ and edges /E/
  /G = {V,E}/
  - /V/ is an int range `1:n`
  - /E/ is represented as forward (or backward for digraph) adjacency lists indexed by vertices
    - edges are also accessed via an iterator
      - that yields `Edge` types containg `(src<:Integer, dst<:Integer)` values
      - both verts and edges may be ints of any type
        - and smallest type that fits the data is recommended in order to save memory

        *Graphs are created using _SimpleGraph() and SimpleDiGraph()_ and more*

        **Multiple edges between two given vertices are not allowed**
        - an attempt to add an edge that already exists in graph *WILL NOT raise an error*
          - this event can be detected using the return val of `add_edge!`

        NOTE: *graphs in which the number of vertices equals or approaches the _typemax_ of the underlying graph element*
        - may encounter *ARITHMETIC OVERFLOW* errors in some functions
_ensure your graph is sized with some spare capacity_


*** AbstractGraph Type

- Graphs.jl is structured around a *few abstract types*
  - developers can base their types on

    _Graphs.AbstractEdge_
    _Graphs.AbstractEdgeIter_
    _Graphs.AbstractGraph_


*All types that are a subset of AbstractGraph must implement the following functions:*
_Base.reverse_
_Base.zero_
_Graphs.dst_
_Graphs.edges_
_Graphs.edgetype_
_Graphs.has_edge_
_Graphs.inneighbors_
_Graphs.is_directed_
_Graphs.ne_
_Graphs.nv_
_Graphs.outneighbors_
_Graphs.src_
_Graphs.vertices_

#+begin_src julia
using Graphs

g = SimpleDiGraph(2)
add_edge!(g, 1, 2)
reverse(first(edges(g)))
# Edge 2 => 1
dst(first(edges(g)))
# 2

g = path_graph(3)
collect(edges(g))
#2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
# Edge 1 => 2
# Edge 2 => 3
edgetype(g)
# SimpleEdge
has_edge(g, 1, 2)
# true
has_edge(g, 2, 1)
# false
has_vertex(SimpleGraph(2), 1)
# true
g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
inneighbors(g, 4)
#2-element Array{Int64,1}:
# 3
# 5
is_directed(SimpleGraph(2))
# false
g = path_graph(3)
ne(g)
# 2
nv(SimpleGraph(3))
# 3
g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
outneighbors(g, 4)
#1-element Array{Int64,1}:
# 5
g = SimpleGraph(2)
add_edge!(g, 1, 2)
src(first(edges(g)))
# 1
collect(vertices(SimpleGraph(4)))
#4-element Array{Int64,1}:
# 1
# 2
# 3
# 4

g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
zero(typeof(g))
# {0, 0} directed simple Int64 graph
zero(g)
# {0, 0} directed simple Int64 graph

#+end_src

*** Source Code for simple undirected graphs

_simple edge_
#+begin_src julia
import Base: Pair, Tuple, show, ==, hash
import Graphs: AbstractEdge, src, dst, reverse

abstract type AbstractSimpleEdge{T<:Integer} <: AbstractEdge{T} end

struct SimpleEdge{T<:Integer} <: AbstractSimpleEdge{T}
    src::T
    dst::T
end

SimpleEdge(t::Tuple) = SimpleEdge(t[1], t[2])
SimpleEdge(p::Pair) = SimpleEdge(p.first, p.second)
SimpleEdge{T}(p::Pair) where T<:Integer = SimpleEdge(T(p.first), T(p.second))
SimpleEdge{T}(t::Tuple) where T<:Integer = SimpleEdge(T(t[1]), T(t[2]))

eltype(::Type{<:ET}) where ET<:AbstractSimpleEdge{T} where T = T

# Accessors
src(e::AbstractSimpleEdge) = e.src
dst(e::AbstractSimpleEdge) = e.dst

# I/O
show(io::IO, e::AbstractSimpleEdge) = print(io, "Edge $(e.src) => $(e.dst)")

# Conversions
Pair(e::AbstractSimpleEdge) = Pair(src(e), dst(e))
Tuple(e::AbstractSimpleEdge) = (src(e), dst(e))

SimpleEdge{T}(e::AbstractSimpleEdge) where T <: Integer = SimpleEdge{T}(T(e.src), T(e.dst))

# Convenience functions
reverse(e::T) where T<:AbstractSimpleEdge = T(dst(e), src(e))
==(e1::AbstractSimpleEdge, e2::AbstractSimpleEdge) = (src(e1) == src(e2) && dst(e1) == dst(e2))
hash(e::AbstractSimpleEdge, h::UInt) = hash(src(e), hash(dst(e), h))
#+end_src

_type for undirected graph_
#+begin_src julia
mutable struct SimpleGraph{T <: Integer} <: AbstractSimpleGraph{T}
    ne::Int
    fadjlist::Vector{Vector{T}} # [src]: (dst, dst, dst)

    function SimpleGraph{T}(ne::Int, fadjlist::Vector{Vector{T}}) where T
        throw_if_invalid_eltype(T)
        new{T}(ne, fadjlist)
    end
end

function SimpleGraph(
    ne,
    fadjlist::Vector{Vector{T}}
) where T

    SimpleGraph{T}(ne, fadjlist)
end

eltype(x::SimpleGraph{T}) where T = T
#+end_src



** Making and Modifying Graphs
- Graphs.jl provides a number of methods for creating a graph object
  - tools for building and manipulating graph objects
    - a wide array of graph generator functions
      - and the ability to read and write graphs from files
        - using _GraphIO.jl_

_Modifying Graphs_
          #+begin_src julia
SimpleGraph{T}
SimpleGraphFromIterator(iter)
eltype(iter) <: SimpleEdge
SimpleDiGraph{T}
SimpleDiGraphFromIterator(iter)
Edge
add_edge!
rem_edge!
add_vertex!
add_vertices!
rem_vertex!
Base.zero(g)
# Return a zero-vertex, zero-edge version of the graph type G
          #+end_src

_Graph Generators_
- Graphs.jl implements many graph generators

  /Graphs.Edge/
  /Graphs.add_vertices!/

  _Datasets_
  - graphs and integration withe the /MatrixDepot.jl/ pkg are available in Datasets submodule of /LightGraphsExtra.jl/
  - selected graphs from Stanford Large Network Dataset Collection may found in /SNAPDatasets.jl/

_ALL GENERATORS_
#+begin_src julia
SimpleDiGraph{T}(nv, ne; seed=-1)
SimpleGraph{T}(nv, ne, edgestream::Channel)
SimpleGraph{T}(nv, ne, smb::StochasticBlockModel)
SimpleGraph{T}(nv, ne; seed=-1)
StochasticBlockModel{T,P}
barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)
barabasi_albert(n::Integer, n0::Integer, k::Integer)
barabasi_albert(n, k)
blockcounts(sbm, A)
dorogovtsev_mendes(n)
erdos_renyi(n, ne)
erdos_renyi(n, p)
expected_degree_graph(ω)
kronecker(SCALE, edgefactor, A=0.57, B=0.19, C=0.19; seed=-1)
make_edgestream(sbm)
random_configuration_model(n, ks)
random_orientation_dag(g)
random_regular_digraph(n, k)
random_regular_graph(n, k)
random_tournament_digraph(n)
static_fitness_model(m, fitness)
static_fitness_model(m, fitness_out, fitness_in)
static_scale_free(n, m, α_out, α_in)
stochastic_block_model(c, n)
# just to name a few theres a bunch...
#+end_src

** Reading/Writing Graphs

Graphs may be written to I/O streams and files using /savegraph/ and read with the /loadgraph/

**the default graph format is compressed Graphs.jl gormat /LG/**

#+begin_src julia

g = erdos_renyi(5, 0.2)

savegraph("mygraph.lgz", g)
reloaded_g = loadgraph("mygraph.lgz")

# dictionaries of graphs can also be saved
# and subsequently re-loaded one by one
graph_dict = {"g1" => erdos_renyi(5, 0.1),
              "g2" => erdos_renyi(10, 0.2),
              "g3" => erdos_renyi(2, 0.9)}

savegraph("mygraph_dict.lg", graph_dict)

# Re-load only graph g1
reloaded_g1 = loadgraph("mygraph_dict.lg", "g1")
#+end_src

*** Source code for loadgraph and savegraph

#+begin_src julia
function loadgraph(fn::AbstractString, gname::AbstractString, format::AbstractGraphFormat)
    open(fn, "r") do io
        loadgraph(auto_decompress(io), gname, format)
    end
end
loadgraph(fn::AbstractString) = loadgraph(fn, "graph", LGFormat())
loadgraph(fn::AbstractString, gname::AbstractString) = loadgraph(fn, gname, LGFormat())
loadgraph(fn::AbstractString, format::AbstractGraphFormat) = loadgraph(fn, "graph", format)


function savegraph(fn::AbstractString, g::AbstractGraph, gname::AbstractString,
        format::AbstractGraphFormat; compress=nothing
    )
    if compress !== nothing
        if !compress
            @info("Note: the `compress` keyword is no longer supported in Graphs. Saving uncompressed.")
        else
            Base.depwarn("Saving compressed graphs is no longer supported in Graphs. Use `LGCompressedFormat()` from the `GraphIO.jl` package instead. Saving uncompressed.", :savegraph)
        end
    end
    io = open(fn, "w")
    try
        return savegraph(io, g, gname, format)
    catch
        rethrow()
    finally
        close(io)
    end
end

# without graph name
savegraph(fn::AbstractString, g::AbstractGraph, format::AbstractGraphFormat; compress=nothing) =
    savegraph(fn, g, "graph", format, compress=compress)

# without format - default to LGFormat()
savegraph(fn::AbstractString, g::AbstractSimpleGraph; compress=nothing) = savegraph(fn, g, "graph", LGFormat(), compress=compress)

#+end_src

** Operators

Graphs.jl implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both SimpleGraph or both SimpleDiGraph).

Base.intersect
Base.join
Base.reverse
Base.reverse!
Base.union
Graphs.cartesian_product
Graphs.complement
Graphs.crosspath
Graphs.difference
Graphs.egonet
Graphs.induced_subgraph
Graphs.merge_vertices
Graphs.merge_vertices!
Graphs.symmetric_difference
Graphs.tensor_product
SparseArrays.blockdiag

** Core functions

Graphs.jl includes the following core functions:

Graphs.add_vertices!
Graphs.all_neighbors
Graphs.common_neighbors
Graphs.degree
Graphs.degree_histogram
Graphs.density
Graphs.has_self_loops
Graphs.indegree
Graphs.is_ordered
Graphs.neighbors
Graphs.num_self_loops
Graphs.outdegree
Graphs.squash
Graphs.weights
Graphs.Δ
Graphs.Δin
Graphs.Δout
Graphs.δ
Graphs.δin
Graphs.δout

** Plotting Graphs

Integrates with _GraphPlot.jl_, _GraphRecipes.jl_, _GraphMakie.jl_, and more

** Path and Traversal
- Graphs.jl provides several traversal and shortest-path algos w/ various utilty functions
  - where appropriate, edge distances may be passed in as a matrix of real-number values

- edge distances for most traversals may be passed in as a _sparse or dense matrix_ of values index by /[src,dst]/ vertices
  - that is /distmx[2,4] = 2.5/ assigns the distance 2.5 to (directed) edge connecting vertex 2 and vertex 4

    _default edge distances are passed in via_

    /DefaultDistance/


*** Traversal
- traversal refers to a process that traverses vertices of a graph
  - following a certain order

    /BreadthFirst/
- provides a breadth first traversal of the graph `g`starting with source vertex `s`,
  - and return a DAG of vertices in the order they were discoverd
- perform a BFS of graph `g` starting from vertex `s`
  - return a vector of parent vertices indexed by vertex
    *this implementation is designed to perform well on large graphs*
#+begin_src julia
bfs(g, s[; dir=:out])
bfs_parents(g, s[; dir=:out])
#+end_src

    /DepthFirst/
- return a topo sort of a directed graph `g` as a vector of vertices
  - in topological order
- return an ordered vector of vertices representing a DAG
  - based on DFS of graph `g` starting with source vertex `s`
      #+begin_src julia
topological_sort_by_dfs(g)
dfs_tree(g, s)
#+end_src

  /MaximumAdjacency/
- return vertices in `g` traversed by maximum adjacency search
  - starting from `s` optionally
  - optional `distmx` matrix
  - if `log` is `true`
    - visitor events will be printed to `io` `STDOUT`
    #+begin_src julia
  maximum_adjacency_visit(g[, distmx][, log][, io][, s])
  maximum_adjacency_visit(g[, s])
    #+end_src


/Diffusion/
- run diffusion simulation for `g` and `n` steps with spread probability based on `p`
  - return a vector with the set of new vertices reached at each step of the simul.
- given results of `diffusion` or params to the `diffusion` itself
  - return the rate of diffusion as a vector resprestnting the cum num of vertices
    - infected at each simulation step
    #+begin_src julia
diffusion(g, p, n)
diffusion_rate(g, p, n; ...)
    #+end_src


/Random Walks/
- perform a random walk on graph `g` starting at `s`
  - continuing for a maximum of `niter` steps
    - return a vector of vertices vistited in order
#+begin_src julia
randomwalk(g, s, niter; seed=-1)
non_backtracking_randomwalk(g, s, niter; seed=-1)
self_avoiding_walk(g, s, niter; seed=-1)
#+end_src

/Connectivity/Bipartiteness/
- connectivity funcs are defined on both undirected and directed graphs
#+begin_src julia
is_connected(g)
is_strongly_connected(g)
is_weakly_connected(g)
connected_components(g)
strongly_connected_components(g)
strongly_connected_components_kosaraju(g)
weakly_connected_components(g)
has_self_loops(g)
attracting_components(g)
is_bipartite(g)
bipartite_map(g) -> Vector{UInt8}
biconnected_components(g) -> Vector{Vector{Edge{eltype(g)}}}
condensation(g[, scc])
neighborhood(g, v, d, distmx=weights(g))
neighborhood_dists(g, v, d, distmx=weights(g))
articulation(g)
bridges(g)
period(g)
isgraphical(degs)
#+end_src

/Cycle Detection/
#+begin_src julia
is_cyclic(g)
cycle_basis(g, root=nothing)
maxsimplecycles(dg::::IsDirected, byscc::Bool = true)
simplecycles(dg::::IsDirected)
simplecycles_iter(dg::DiGraph, ceiling = 10^6)
simplecycles_hawick_james(g)
simplecyclescount(dg::DiGraph, ceiling = 10^6)
simplecycleslength(dg::DiGraph, ceiling = 10^6)
simplecycles_limited_length(g, n, ceiling=10^6)
karp_minimum_cycle_mean(g[, distmx])

#+end_src

/Minimum Spanning Trees/
#+begin_src julia
kruskal_mst(g, distmx=weights(g); minimize=true)
prim_mst(g, distmx=weights(g))

#+end_src

/Shortest-Path/
#+begin_src julia
a_star(g, s, t[, distmx][, heuristic])
dijkstra_shortest_paths(g, srcs, distmx=weights(g));
desopo_pape_shortest_paths(g, src, distmx=weights(g))
bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))
floyd_warshall_shortest_paths(g, distmx=weights(g))
yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);
spfa_shortest_paths(g, s, distmx=weights(g))

#+end_src

/Path discovery/enumeration/
#+begin_src julia
gdistances(g, source; sort_alg=QuickSort)
gdistances!(g, source, dists; sort_alg=QuickSort)
enumerate_paths(state[, vs])
AbstractPathState
struct DijkstraState{T, U}
struct DEposoPapeState{T, U}
BellmanFordState{T, U}
struct FloydWarshallState{T, U}
struct YenState{T, U}

#+end_src

** Distance Measurement
#+begin_src julia
BoundedMinkowskiCost(μ₁, μ₂)
MinkowskiCost(μ₁, μ₂; p::Real=1)
center(eccentricities)
center(g, distmx=weights(g))
diameter(eccentricities)
diameter(g, distmx=weights(g))
eccentricity(g[, v][, distmx])
eccentricity(g[, vs][, distmx])
edit_distance(G₁::AbstractGraph, G₂::AbstractGraph)
edit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))
periphery(eccentricities)
periphery(g, distmx=weights(g))
radius(eccentricities)
radius(g, distmx=weights(g))
transitiveclosure(g, selflooped=false)
transitiveclosure(g, selflooped=false)

#+end_src
** Centrality Measures
#+begin_src julia
betweenness_centrality(g[, vs])
betweenness_centrality(g, k)
closeness_centrality(g, distmx=weights(g); normalize=true)
degree_centrality(g)
indegree_centrality(g)
outdegree_centrality(g)
eigenvector_centrality(g)
katz_centrality(g, α=0.3)
pagerank(g, α=0.85, n=100, ϵ=1.0e-6)
stress_centrality(g[, vs])
stress_centrality(g, k)
radiality_centrality(g)

#+end_src

** Linear Algebra

/LinAlg/ is the pkg for using the type system to check types of graph matrices

- the core /Adjacency/ matrix type
  - subtypes represent the different normalizations of the adj matrix

        /AveragingAdjacency/ /AveragingLaplacian/ /CombinatorialAdjacency/ /GraphMatrix/ /NormalizedAdjacency/ /NormalizedLaplacian/ /StochasticAdjacency/ /StochasticLaplacian/
- /Noop/ represents no action
- /degrees(adjmat)/
  - returns the degrees of a graph represnted by /CombinatorialAdjacency/ `adjmat`
- /degrees(graphmx)/
  - returns the degrees of a graph represented by graph matrix `graphmx`
- /symmetrize(A::SparseMatrix, which=:or)/
  - return a symmetric version of graph as a sparse matrix
    - which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs
- /symmetrize(adjmat, which=:or)/
  - return a symmetric version of graph (represented by CombinatorialAdjacency adjmat) as a CombinatorialAdjacency
- /adjacency_matrix(g[, T=Int; dir:=out])/
  - Return a sparse adjacency matrix for a graph, indexed by [u, v] vertices
- /adjacency_spectrum(g[, T=Int; dir=:unspec])/
  - Return the eigenvalues of the adjacency matrix for a graph g, indexed by vertex
- /incidence_matrix(g[, T=Int; oriented=false])/
  - Return a sparse node-arc incidence matrix for a graph, indexed by [v, i], where i is in 1:ne(g), indexing an edge e
- /laplacian_matrix(g[, T=Int; dir=:unspec])/
  - Return a sparse Laplacian matrix for a graph g, indexed by [u, v] vertices
- /laplacian_spectrum(g[, T=Int; dir=:unspec])/
  - Return the eigenvalues of the Laplacian matrix for a graph g, indexed by vertex
- /spectral_distance(G₁, G₂ [, k])/
  - Compute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k greatest eigenvalues


* LEMON
LEMON stands for _Lib for Efficient Modeling and Optimization_
 - cpp template library for providing efficient implementations of data structs and algos
   - focus on combinatorial optimization tasks connected
     - connected mainly with graphs and networks
       - for telecommunication, computer networks, logistics, scheduling, and other areas
** Installation Instructions
 _building and installing LEMON from source on Linux_
 #+begin_src bash
cd lemon-x.y.z
mkdir build && cd build
cmake ..
make
make check
make html
make install
 #+end_src

** Compile your First Code

_a directed graph is created with 2 nodes and an arc is added to it_
#+begin_src cpp
#include <iostream>
#include <lemon/list_graph.h>

using namespace lemon;
using namespace std;

int main()
  {
    ListDigraph g;
    ListDigraph::Node u = g.addNode();
    ListDigraph::Node v = g.addNode();
    ListDigraph::Arc a = g.addArc(u, v);

    cout << "hello world! this is LEMON" << end1;
    cout << "we have a directed graph with " << countNodes(g) << " nodes"
         << " and " << countArcs(g) << " arc" << end1;
    return 0;
  }
#+end_src

- compile this code
  #+begin_src
# system-wide LEMON install
g++ -o hello_lemon hello_lemon.cc -lemon

# executable
./hello_lemon

# user-local LEMON install
g++ -o hello_lemon -I ~/lemon/include hello_lemon.cc -L ~/lemon/lib -lemon

  #+end_src


** Basic Concepts

we work the with `lemon` namespace
- please assume that below directive is added to all code snippets
  `using namespace lemon;`

*** Directed Graphs
- most versatile digraph structure `ListDiGraph`
  - there are more digraph types
- include the header file
- default constructor of the class creates empty graph
- nodes and arcs are identified by two data types
  - Node and Arc
    - you can add items to the graph using member functions
    - parallel and loop arcs are supported
- you can also remove nodes/arcs with erase()
  - there are several more options to remove but not every graph item supports deletion
- source() and target() give back the two nodes of an arc
- each graph item has a non-negative int identifier using the id()
  - identifiers are unique w.r.t. a certain itemtype in a graph
    - a node and an arc may have the same ID
    #+begin_src cpp
#include <lemon/list_graph.h>
ListDigraph g;
ListDigraph::Node x = g.addNode();
ListDigraph::Node y = g.addNode();
ListDigraph::Node z = g.addNode();
g.addArc(x,y);
g.addArc(y,z);
g.addArc(z,x);

ListDigraph::Arc parallel = g.addArc(x,y);
ListDigraph::Arc loop = g.addArc(x,x);

if (g.source(loop) == g.target(loop))
  std::cout << "This is a loop arc" << std::endl;

std::cout << "Arc " << g.id(arc) << " goes from node "
  << g.id(g.source(arc)) << " to node " << g.id(g.target(arc)) << std::endl;
#+end_src


*** Iterators
- graph strucutres provide several iterators
  - using /NodeIt/ lists nodes
    - name of iter type starts with a name that refers to the iterated objects
    - *INVALID is a constant in lemon namespace*

*CONTRARY TO THE ITERATORS IN C++ STL, LEMON ITERATORS ARE CONVERTIBLE TO ITEM TYPES*
 _without having to use operator*()_

 - graph items are ordered by `less than` operator (w.r.t. to int identifiers)

- using /ArcIt/ lists arcs
  - you can list arcs starting from/arriving at a certain node
    - /OutArcIt/ /InArcIt/

- LEMON provides counting functions
  - countNodes(), countArcs(), countInArcs(), countOutArcs()
    **Using them is not just simpler than the above loops, but they could be much faster, since several graph types support constant time item counting**
       #+begin_src cpp
 int cnt = 0;
 for (ListDigraph::NodeIt n(g); n != INVALID; ++n)
     cnt++;
 std::cout << "number of nodes:" << cnt << std::endl;

 // add full graph to existing nodes
 for (ListDigraph::NodeIt u(g); u != INVALID; ++u)
   for (ListDigraph::NodeIt v(g); v != INVALID; ++v)
     if (u != v) g.addArc(u, v);

// only add one of the opposite arcs
for (ListDigraph::NodeIt u(g); u != INVALID; ++u)
  for (ListDigraph::NodeIt v(g); v != INVALID; ++v)
    if (u < v) g.addArc(u, v);

int cnt = 0;
for (ListDigraph::ArcIt a(g); a != INVALID; ++a)
  cnt++;
std::cout << "Number of arcs: " << cnt << std::endl;

int cnt = 0;
for (ListDigraph::OutArcIt a(g, x); a != INVALID; ++a)
  cnt++;
std::cout << "Number of arcs leaving the node 'x': " << cnt << std::endl;
       #+end_src



*** Maps
- maps allows assigning values of any type to the node or arcs of a graph
  _maps enable FAST read/write, DYNAMIC alloc/dealloc, AUTOMATIC storage construction/destruction_

  **graph classes represent pure graph structure, data that is assigned to the items of the graph MUST be stored separately using maps**

- to assign int values to each node
  - you alloc a NodeMap<int>
- any data typed w/ a default constructor can be assigned to graph items

- when a map is created
  - you can give an initial values of the elements as a second parameter


  #+begin_src cpp
ListDigraph::NodeMap<int> map(g);
map[x] = 2;
map[y] = 3;
map[z] = map[x] + map[y];
ListDigraph::NodeMap<std::string> name(g);
name[x] = "Node A";
name[y] = "Node B";

// create a map that assigns char labels to the nodes
ListDigraph::NodeMap<char> label(g);
char ch = 'A';
for (ListDigraph::NodeIt n(g); n != INVALID; ++n)
  label[n] = ch++;

// puts the number of outgoing arcs for each node in map
ListDigraph::NodeMap<int> out_deg(g, 0);
for (ListDigraph::ArcIt a(g); a != INVALID; ++a)
  out_deg[g.source(a)]++;
  #+end_src



** Algorithms

LEMON provides well-known fundamental algorithms for discovering graph properties
- and even complex optimisation algorithms

*** Graph Search

- commonly we have BFS, DFS implemented as classes `Bfs` and `Dfs`
  - algos are placed in separated files named after the algo

**All algorithms are implemented in _template classes_ **
- typically template params specify the used graph type and required map types
- you can execute the algo by calling run()

**by default distances and path info are stored in internal maps**
- access with distMap() and predMap() or dist(),path(),predNode(),predArc()

- call init() to initialize internal data structures
  - instead of run() have more control executing algo step-by-step
  - add one or more source nodes to the queue
    - and they'll be processed just like the run()
  - start path computation with the start()
    - or write your own loop to process nodes one-by-one

#+begin_src cpp

#include <lemon/bfs.h>
ListDigraph g;
Bfs<ListDigraph> bfs(g);
// find shortest path from s to all other nodes
bfs.run(s);
// find shortest path from s to target node t
bfs.run(s,t);

// print the shortest path of those nodes that are at most in a certain distnace `max_dist`
for (ListGraph::NodeIt n(g); n != INVALID; ++n) {
  if (bfs.reached(n) && bfs.dist(n) <= max_dist) {
    std::cout << gr.id(n);
    Node prev = bfs.prevNode(n);
    while (prev != INVALID) {
      std::cout << "<-" << gr.id(prev);
      prev = bfs.prevNode(n);
    }
    std::cout << std::endl;
  }
}

bfs.init();
bfs.addSource(s1);
bfs.addSource(s2);
bfs.start(t);

// execution reaches all nodes in the digraph
// ... algo is started for each node that is not visited before
bfs.init();
for (NodeIt n(g); n != INVALID; ++n) {
  if (!bfs.reached(n)) {
    bfs.addSource(n);
    bfs.start();
  }
}

// bfs.start() is only a shortcut of following code
while (!bfs.emptyQueue()) {
  bfs.processNextNode();
}
#+end_src


*** Shortest Paths

the LEMON Dijkstra class
#+begin_src cpp
dijkstra(g, length).distMap(dist).run(s,t);
// or use class inteface like below
// execution is controlled to a higher extent
Dijkstra<ListDigraph> dijkstra(g, length);
dijkstra.distMap(dist);
dijsktra.init();
dijkstra.addSource(s);
dijkstra.start();

// instaed of using .start()
while (!dijkstra.emptyQueue()) {
  ListDigraph::Node n = dijkstra.processNextNode();
  cout << g.id(n) << ' ' << dijkstra.dist(g) << endl;
}
#+end_src

- LEMON provides other algos for finding shortest paths
** Style Guide
*** Naming Conventions
- in LEMON the name of a source file is written in lowercase and words are separated with underscores
  - all header files are located in the lemon subdir

    `#include <lemon/header_file.h>`

- the name of the a class or any type look like
  `AllWordsCapitalizedWithoutUnderscores`

- the name of a function looks like
  `firstWorldLowercaseRestCapitalizedWithoutUnderscores`

- the names of constants and macros look like
  `ALL_UPPERCASE_WITH_UNDERSCORES`



** LEMON Graph Format (LGF)
- LGF is a column-oriented file format for storing graphs and associated data like node and edges maps

- each line with `#` first non-whitespace char is considered a comment line
  - otherwise the file consists of sections starting with a header line

- the header line starts with `@` char
  - followed by the section type `@nodes, @arcs, @edges, @attributes`
    - each header line may have an optional name to distinguish sections

- the standard sections are column-oriented
  - consisting of tokens separated by whitespaces
    - a token can be plain or quoted
      - plain token is a sequence of non-whitespace chars
      - quoted token is a char sequence surrounded by """"
        - can contain whitespaces and escape sequences

          _@nodes describes a set of nodes and associated maps_
          _@arcs describes the names of the maps but label is not obligatory_
          - if no map in @arcs then a sole `-` exists in the first line
          _@edges is just a synonym of @arcs_,
          - @arcs section can store the edgeset of an undirected graph
          _@attributes sections contains KV pairs_
          - consisting of two tokens on each line
            - an attribute name and an attribute value

          #+begin_src
 @nodes
 label  coordinates  size    title
 1      (10,20)      10      "First node"
 2      (80,80)      8       "Second node"
 3      (40,10)      10      "Third node"
...

 @arcs
         capacity
 1   2   16
 1   3   12
 2   3   18
...

 @arcs
         -
 1   2
 1   3
 2   3
...

 @attributes
 source 1
 target 3
 caption "LEMON test digraph"
          #+end_src
