#+title: Lemon Graphs


* Graphs.jl
- network and graph analysis in julia
  - offering concrete graph implementations
    - /SimpleGraph/ for undirected graphs
    - /SimpleDiGraph/ for directed graphs
      - /AbstractGraph/ abstract type

- central package of JuliaGraphs ecosystem
  - additional functionality via
    - LightGraphsExtras.jl, MetaGraphs.jl, SimpleWeightedGraphs.jl, GraphIO.jl
      GraphDataFrameBridge.jl

basic example
#+begin_src julia
using Graphs

g = path_graph(6)
# # of verts
nv(g)
# # of edges
ne(g)
# add edge to make path a loop
add_edge!(g, 1, 6)
#+end_src

** Graph Types
- In addition to /SimpleGraph/SimpleDiGraph/
  - Graphs serves alternative graph types
    - (un)directed graphs with the ability to specify weights on edges
    - (un)directed graphs that supports UDF properties on graph, verts, and edges
    - supports massive graph structures in a space-time efficient manner
      - but is static, meaning its immutable once instantiated

        _which to use_?
        - prefer the simple implementaitons!
          - if we need edge weights and does NOT require large numbers of graph manipulations--use weighted graphs
            - if we need labeling of verts/edges use metadata graphs
              - if we have graphs with billions to tens of billions of edges and dont need mutability-- use static graphs

*** Concrete Types
1. _SimpleGraph_ and _SimpleDiGraph_
 - subtypes of _AbstractGraphs_ and system default integer type of Int64


- a graph /G/ is described by a set of vertices /V/ and edges /E/
  /G = {V,E}/
  - /V/ is an int range `1:n`
  - /E/ is represented as forward (or backward for digraph) adjacency lists indexed by vertices
    - edges are also accessed via an iterator
      - that yields `Edge` types containg `(src<:Integer, dst<:Integer)` values
      - both verts and edges may be ints of any type
        - and smallest type that fits the data is recommended in order to save memory

        *Graphs are created using _SimpleGraph() and SimpleDiGraph()_ and more*

        **Multiple edges between two given vertices are not allowed**
        - an attempt to add an edge that already exists in graph *WILL NOT raise an error*
          - this event can be detected using the return val of `add_edge!`

        NOTE: *graphs in which the number of vertices equals or approaches the _typemax_ of the underlying graph element*
        - may encounter *ARITHMETIC OVERFLOW* errors in some functions
_ensure your graph is sized with some spare capacity_


*** AbstractGraph Type

- Graphs.jl is structured around a *few abstract types*
  - developers can base their types on

    _Graphs.AbstractEdge_
    _Graphs.AbstractEdgeIter_
    _Graphs.AbstractGraph_


*All types that are a subset of AbstractGraph must implement the following functions:*
_Base.reverse_
_Base.zero_
_Graphs.dst_
_Graphs.edges_
_Graphs.edgetype_
_Graphs.has_edge_
_Graphs.inneighbors_
_Graphs.is_directed_
_Graphs.ne_
_Graphs.nv_
_Graphs.outneighbors_
_Graphs.src_
_Graphs.vertices_

#+begin_src julia
using Graphs

g = SimpleDiGraph(2)
add_edge!(g, 1, 2)
reverse(first(edges(g)))
# Edge 2 => 1
dst(first(edges(g)))
# 2

g = path_graph(3)
collect(edges(g))
#2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
# Edge 1 => 2
# Edge 2 => 3
edgetype(g)
# SimpleEdge
has_edge(g, 1, 2)
# true
has_edge(g, 2, 1)
# false
has_vertex(SimpleGraph(2), 1)
# true
g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
inneighbors(g, 4)
#2-element Array{Int64,1}:
# 3
# 5
is_directed(SimpleGraph(2))
# false
g = path_graph(3)
ne(g)
# 2
nv(SimpleGraph(3))
# 3
g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
outneighbors(g, 4)
#1-element Array{Int64,1}:
# 5
g = SimpleGraph(2)
add_edge!(g, 1, 2)
src(first(edges(g)))
# 1
collect(vertices(SimpleGraph(4)))
#4-element Array{Int64,1}:
# 1
# 2
# 3
# 4

g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);
zero(typeof(g))
# {0, 0} directed simple Int64 graph
zero(g)
# {0, 0} directed simple Int64 graph

#+end_src
